const express = require('express');
const { createServer } = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const axios = require('axios');
require('dotenv').config();

// Import handlers
const { socketAuthMiddleware } = require('./auth');
const { setupLocationHandlers, setupLocationEndpoints } = require('./location_handler');
const { setupNotificationHandlers, setupNotificationEndpoints } = require('./notification_handler');

const app = express();
const httpServer = createServer(app);

// CORS configuration
app.use(cors({
  origin: '*',  // Allow all origins for development
  methods: ['GET', 'POST']
}));

app.use(express.json());

// Socket.IO server with CORS
const io = new Server(httpServer, {
  cors: {
    origin: '*',  // Allow all origins for development
    methods: ['GET', 'POST']
  }
});

// Configuration
const PORT = process.env.SOCKET_PORT || 3000;
const DJANGO_API_URL = process.env.DJANGO_API_URL || 'http://localhost:8000';

// Store active connections
// Format: { userId: socketId, busId: [parentSocketIds], driverSocketId: socketId }
const connections = {
  parents: new Map(),  // Map of parent user_id to socket
  drivers: new Map(),  // Map of driver user_id to socket
  admins: new Map(),   // Map of admin user_id to socket
  buses: new Map(),    // Map of bus_id to array of parent sockets
};

// Apply authentication middleware
io.use(socketAuthMiddleware);

// Socket.IO connection handler
io.on('connection', (socket) => {
  console.log(`âœ… Client connected: ${socket.id}, User ID: ${socket.userId}, Type: ${socket.userType}`);

  // Setup handlers based on user type
  setupLocationHandlers(socket, io);
  setupNotificationHandlers(socket, io);

  // Handle parent connection
  if (socket.userType === 'parent') {
    connections.parents.set(socket.userId, socket);

    // Parent subscribes to their child's bus (support both event names)
    const handleSubscribe = async (data) => {
      const busId = data.busId || data;

      // Verify parent has access to this bus (call Django API)
      try {
        const response = await axios.get(`${DJANGO_API_URL}/api/parents/${socket.userId}/children/`, {
          headers: { 'Authorization': `Bearer ${socket.handshake.auth.token}` }
        });

        const children = response.data.children || [];

        // Check both bus_id and assignedBus.id
        const hasAccess = children.some(child => {
          const childBusId = child.bus_id || child.assignedBus?.id;
          return childBusId === parseInt(busId);
        });

        if (hasAccess) {
          socket.join(`bus_${busId}`);

          // Track this parent for this bus
          if (!connections.buses.has(busId)) {
            connections.buses.set(busId, new Set());
          }
          connections.buses.get(busId).add(socket.userId);

          socket.emit('subscribed', { busId, success: true });
          console.log(`âœ… Parent ${socket.userId} subscribed to bus ${busId}`);
        } else {
          socket.emit('error', { message: 'Access denied to this bus' });
        }
      } catch (error) {
        console.error('âŒ Error verifying bus access:', error.message);
        socket.emit('error', { message: 'Failed to verify bus access' });
      }
    };

    socket.on('subscribe_to_bus', handleSubscribe);
    socket.on('subscribe_bus', handleSubscribe); // Support both event names
  }

  // Handle driver connection
  if (socket.userType === 'driver') {
    connections.drivers.set(socket.userId, socket);
  }

  // Handle admin connection
  if (socket.userType === 'admin') {
    connections.admins.set(socket.userId, socket);

    // Admin subscribes to monitor all buses or specific buses
    socket.on('subscribe_to_bus', (data) => {
      const busId = data.busId || data;

      if (busId === 'all') {
        // Subscribe to all buses
        socket.join('admin_all_buses');
        console.log(`âœ… Admin ${socket.userId} subscribed to ALL buses`);
        socket.emit('subscribed', { busId: 'all', success: true });
      } else {
        // Subscribe to specific bus
        socket.join(`bus_${busId}`);
        socket.join(`admin_bus_${busId}`);
        console.log(`âœ… Admin ${socket.userId} subscribed to bus ${busId}`);
        socket.emit('subscribed', { busId, success: true });
      }
    });

    // Admin unsubscribes from a bus
    socket.on('unsubscribe_from_bus', (data) => {
      const busId = data.busId || data;

      if (busId === 'all') {
        socket.leave('admin_all_buses');
        console.log(`Admin ${socket.userId} unsubscribed from ALL buses`);
      } else {
        socket.leave(`bus_${busId}`);
        socket.leave(`admin_bus_${busId}`);
        console.log(`Admin ${socket.userId} unsubscribed from bus ${busId}`);
      }

      socket.emit('unsubscribed', { busId, success: true });
    });

    // Admin requests current status of all active trips
    socket.on('request_active_trips', async () => {
      try {
        const response = await axios.get(`${DJANGO_API_URL}/api/trips/?status=in-progress`, {
          headers: { 'Authorization': `Bearer ${socket.handshake.auth.token}` }
        });

        socket.emit('active_trips', {
          trips: response.data.results || response.data || [],
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        console.error('âŒ Error fetching active trips:', error.message);
        socket.emit('error', { message: 'Failed to fetch active trips' });
      }
    });
  }

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log(`âŒ Client disconnected: ${socket.id}, User ID: ${socket.userId}`);

    if (socket.userType === 'parent') {
      connections.parents.delete(socket.userId);

      // Remove from bus subscriptions
      connections.buses.forEach((parents, busId) => {
        parents.delete(socket.userId);
        if (parents.size === 0) {
          connections.buses.delete(busId);
        }
      });
    } else if (socket.userType === 'driver') {
      connections.drivers.delete(socket.userId);
    } else if (socket.userType === 'admin') {
      connections.admins.delete(socket.userId);
    }
  });
});

// Setup REST endpoints for notifications and locations
setupNotificationEndpoints(app, io, connections);
setupLocationEndpoints(app, io);

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    connections: {
      parents: connections.parents.size,
      drivers: connections.drivers.size,
      admins: connections.admins.size,
      buses: connections.buses.size
    }
  });
});

// Start server (listen on all interfaces)
httpServer.listen(PORT, '0.0.0.0', () => {
  console.log('=====================================');
  console.log(`ğŸš€ Socket.IO Server Running`);
  console.log(`ğŸ“¡ Port: ${PORT}`);
  console.log(`ğŸ”— Django API: ${DJANGO_API_URL}`);
  console.log(`ğŸŒ Server: http://192.168.100.65:${PORT}`);
  console.log('=====================================');
  console.log('ğŸ“‚ Modules loaded:');
  console.log('  âœ… Authentication (auth.js)');
  console.log('  âœ… Location Handler (location_handler.js)');
  console.log('  âœ… Notification Handler (notification_handler.js)');
  console.log('=====================================');
  console.log('â³ Waiting for connections...\n');
});
